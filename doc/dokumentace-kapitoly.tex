% dokumentace-kapitoly.tex
% Tex soubor s jednotlivými kapitolami pro dokumentaci k projektu do předmětu GAL
% Autoři: Bc. Jan Bíl
%         Bc. Michal Šedý
% Poslední úprava: 08.11.2022

\chapter{Úvod}
    Orientovaný graf je struktura popisující množinu bodů (uzlů), které jsou mezi sebou propojeny orientovanými hranami. Cyklus v orientovaném grafu představuje takovou spojitou posloupnost uzlů, že se žádný uzel s výjimkou prvního a posledního v sekvenci neopakuje, a zároveň pro dvojici sousedících uzlů v posloupnosti $\dots u_m u_n \dots$ platí, že existuje orientovaná hrana vedoucí z uzlu $u_m$ do uzlu $u_n$. Tato práce se zabývá porovnáním algoritmů pro získání seznamu všech existujících cyklů v zadaném orientovaném grafu.

    Vyhledávání (výčet) všech cyklů v grafu je využíváno v mnoha oblastech teorie grafů. Tato informace je používána k optimalizaci počítačových programů \cite{Program_optimization}, při analýze booleovských sítí využívaných pro modelování biologických sítí nebo sítí genových regulátorů \cite{Biology}, při návrhu a vývoji komunikačních systému \cite{How_loopy_is_your_network} nebo ověření jejich spolehlivosti a fault-tolerance \cite{Network_Reliability}, atd.

    Tato páce byla vytvořena v rámci projektu "Porovnání - Hledání cyklů"~do předmětu GAL (grafové algoritmy) a zkoumá efektivitu tři algoritmů pro výčet všech cyklů v orientovaných grafech. Na úvod jsou definovány základní pojmy a algoritmy týkající se orientovaných grafů. V následujících kapitolách jsou pak uvedeny jednotlivé algoritmy. Kapitola \ref{chapter:Algo1} popisuje přímočarý algoritmus \cite[str. 287]{Book_algo}, který postupně generuje různé kandidáty cyklů, kteří jsou následně ověřování. Algoritmus, který navrhl Herbert Weinblatt využívající zpětné navrácení \cite{A_new_search_algorithm} je uveden v kapitole \ref{chapter:Algo2}. Kapitola \ref{chapter:Algo3} popisuje algoritmus Hongbo Liu a Jiaxin Wanga \cite{A_new_way_to_enumerate_cycles_in_graph}, který využívající frontu. Všechny tyto algoritmy byly implementovány v jazyce Python 3. Popis návrhu aplikace pro výčet cyklů pomocí vybraného algoritmu, včetně jejího používání jsou uvedeny v kapitolách \ref{chapter:Design} a \ref{chapter:Help}. Experimenty porovnávající efektivitu jednotlivých postupů výčtu všech cyklů jsou uvedeny v kapitole \ref{chapter:Experiments}. Mimo již zmíněných algoritmů byl také testován Johnsonův algoritmus \cite{Johnson_1975} poskytován knihovnou Networkx\footnote{Dostupné z \url{https://networkx.org}}.

\chapter{Prerekvizity}
    \label{chapter:Intro}
    Tato kapitola poskytuje definice pojmů spojených s orientovanými grafy, jakými jsou definice orientovaného grafu, sledu, cesty a cyklu. Dále jsou popsány základní algoritmy pro práci s grafy, kterými jsou prohledávání do hloubky (DFS) a topologické uspořádání, které jsou využívány pro zjednodušení grafů při vyhledávání cyklů. Tato kapitola je převzata z~\cite{Prezentace}.

    \section{Orientovaný graf}
        \begin{definition}
            \textbf{Orientovaný graf} je uspořádaná dvojice $G = (V, E)$, kde $V$ je množina uzlů grafu a $E \subseteq V \times V$ je množina orientovaných hran, kde hrana $(u, v) \in E$ znamená, že v grafu $G$ vede hrana z uzlu $u$ do uzlu $v$ (uzly $u, v$ jsou incidentní).
        \end{definition}

        \vspace*{1em}
        Mějme orientovaný graf $G = (V, E)$ a nechť $u, v \in V$, pak lez graf $G$ reprezentovat v~algoritmech dvěma různými způsoby. 1) jako pole $Adj$ seznamů sousedů, pro které platí $v \in Adj[u] \iff (u, v) \in E$. 2) jako incidentní matici $Adj_M$, kde $Adj_M[u][v] = 1 \iff (u, v) \in E$ a zároveň  $Adj_M[u][v] = 0 \iff (u, v) \notin E$. Pro účely této práce byl zvolen první přístup, kterým je pole seznamů sousedů.

        \begin{definition}
            Nechť $G = (V, E)$ je orientovaný graf. \textbf{Transponovaný graf} grafu $G$ je $G^T = (V, E^T)$, kde $E^T = \{(v, u)\,|\, (u, v) \in E\}$.
        \end{definition}

        \begin{definition}
            \textbf{Vstupní stupeň uzlu} je dán funkcí $d_+ : V \rightarrow \mathbb{N}_0$, která udává počet přechodu vstupujících do daného uzlu.
        \end{definition}

        \begin{definition}
            \textbf{Vstupní stupeň uzlu} je dán funkcí $d_- : V \rightarrow \mathbb{N}_0$, která udává počet přechodu vystupujících do daného uzlu.
        \end{definition}

        \vspace*{1em}
        Lze snadno ukázat, že pokud má uzel $u \in V$ hodnotu $d_-(u) = 0$ nebo $d_+(u) = 0$, pak nemůže být součástí žádného cyklu, protože pro každý stav obsažný v cyklu musí platit, že jeho vstupní i výstupní stupeň je nenulový, jinak by nemohl být cyklus "uzavřen". Tyto uzly s nulovým stupněm mohou být v části přípravy algoritmů pro výčet cyklů zanedbány (odstraněny). Toto zanedbání uzlu může snížit hodnotu vstupních nebo vstupních stupňů uzlů s ním incidentních na nulu. V~takovém případě mohou být dále zanedbány také tyto uzly.

        \begin{definition}
            \textbf{Sled} je posloupnost vrcholů $\langle v_0 \dots v_n\rangle$, kde $n \in \mathbb{N}$, $v_i \in V$ pro $0 \leq i \leq n$, a $(v_{j-1}, v_j) \in E$ pro $1 \leq j \leq n$.
        \end{definition}

        \begin{definition}
            \textbf{Cesta} (otevřená) je sled, ve kterém se neopakují uzly.
        \end{definition}

        \begin{definition}
            \textbf{Cyklus} je cesta, ve které shoduje první a poslední uzel.
        \end{definition}

    \section{Prohledávání do hloubky}
        Algoritmus prohledávání do hloubky (DFS) je základním algoritmem pro práci s grafy. DFS postupně prochází všechny uzly grafu $G = (V, E)$ a vytváří les prohledávání do hloubky.

        \begin{definition}
            Nechť $G = (V, E)$ je orientovaný graf a $\pi$ je pole předchůdců, kde $u \in \pi[v] \implies (u, v) \in E$. \textbf{Les prohledávání do hloubky} je orientovaný graf $G_\pi = (V, E_\pi)$, kde $E_\pi = \{(u, v) \in E\,|\, u = \pi[v]\}$.
        \end{definition}

        \vspace*{1em}
        Během výpočtu se vytváří pole barev uzlů $color[u] \in \{WHITE, GRAY, BLACK\}$, pole časů prvního prozkoumání $d[u] \in \mathbb{N}$, pole časů dokončení prozkoumávání seznamu sousedů $f[u] \in \mathbb{N}$ a pole předchůdců $\pi[u] \subseteq V$.

        \begin{algorithm}
            \DontPrintSemicolon
            \caption{DFS}
            \KwIn{$G := (V, E)$}
            \KwOut{$\pi, d, f$}
            \vspace*{0.5em}

            \SetKwProg{myalg}{Procedure}{}{}
                \myalg{\textnormal{DFS--VISIT(v)}}{
                    $color[u] \leftarrow \textit{GRAY}$\;
                    $d[u] \leftarrow time \leftarrow time + 1$\;
                    \For{$v \in Adj$}
                    {
                        \If{$color[v] = \textit{WHITE}$}
                        {
                            $\textnormal{DFS--VISIT}(v)$\;
                        }
                    }

                }{\textbf{end}}
            \vspace*{0.5em}

            \For{$u \in V$}
            {
                $color[u] \leftarrow \textit{WHITE}$\;
                $\pi[u] \leftarrow \textit{NIL}$\;
            }
            \vspace*{0.5em}

            $time \leftarrow 0$\;
            \For{$u \in V$}
            {
                \If{$color[u] = \textit{WHITE}$}
                {
                    $\textnormal{DFS--VISIT}(u)$\;
                }
            }
            \vspace*{0.5em}

            \KwRet{$\pi, d, f$}

        \end{algorithm}

        \newpage

        \begin{theorem}
            Časová složitost algoritmu DFS je $\mathcal{O}(|V| + |E|)$.
        \end{theorem}

        \begin{proof}
            Inicializační část (10--13) má časovou složitost $\mathcal{O}(|V|)$. Hlavní cyklus 15--19 je prováděn maximálně $|V|$-krát, tedy časová obtížnost je $\mathcal{O}(|V|)$. Funkce DFS-VISIT je spouště na pouze pro bílé uzly, tedy $|V|$-krát a cyklus v proceduře 4--8 je proveden maximálně $|Adj[v]|$-krát. Protože $\sum_{v \in V}|Adj[v]| = |E|$ je časová obtížnost cyklu 4--8 $\mathcal{O}(|E|)$. Celková složitost je tedy $\mathcal{O}(|V| + |E|)$.
        \end{proof}

    \section{Topologické uspořádání}
        \begin{definition}
            \textbf{Topologické uspořádání} orientovaného grafu $G = (V, E)$ je lineární uspořádání všech uzlů tak, že pokud $(u, v) \in E$, pak uzel $u$ předchází uzel $v$ v daném uspořádání.
        \end{definition}

        \vspace*{1em}
        Pokud graf $G$ obsahuje cykly, poté není možné určit topologické uspořádání. Nicméně algoritmus lze spustit. Výsledkem bude \textit{pseudo-topologické uspořádání}, ve kterém bude platit, že pokud $(u, v) \in E$ a zároveň se $u$ nenachází v~žádném cyklu, pak $u$ předchází $v$~v~daném uspořádání.

        \begin{algorithm}
            \DontPrintSemicolon
            \caption{Topological-sort}
            \KwIn{$G := (V, E)$}
            \KwOut{$L$}
            \vspace*{0.5em}

            zavolej DFS($G$) pro výpočet hodnot $f[v]$\;
            každý dokončený uzel zařaď na začátek seznamu uzlů $L$\;
            \vspace*{0.5em}

            \KwRet{$L$}
        \end{algorithm}

        \begin{theorem}
            Časová složitost algoritmu \textit{topologického uspořádání} je $\mathcal{O}(|V| + |E|)$.
        \end{theorem}
        \begin{proof}
            Protože výpočet topologického uspořádání využívá pouze DFS v časovou složitostí $\mathcal{O}(|V| + |E|)$ a operaci vložení na začátek seznamu, která má konstantní časovou složitost, je časová složitost topologického uspořádání $\mathcal{O}(|V| + |E|)$.
        \end{proof}

    \section{Zanedbání stavů}

        Jak již bylo dříve řečeno, uzly, jejichž vstupní nebo výstupní stupeň je nulový, nemohou být součástí žádného cyklu, a proto mohou být při výčtu všech cyklů grafu zanedbány (odstraněny). Při zanedbání těchto uzlů se ale mohou změnit hodnoty funkcí $d_-$ a $d_+$ uzlů s nimi incidentiními tak, že budou objeveny nové uzly s nulovým vstupním nebo výstupním stupněm. Pro jejich kompletní eliminaci slouží algoritmus \ref{algo:ZanedbaniStavu}.

        \begin{theorem}
            Časová složitost algoritmu zanedbání stavů je $\mathcal{O}(|V| + |E|)$.
        \end{theorem}

        \begin{proof}
            Transponování grafu má časovou složitost $\mathcal{O}(|V| + |E|)$. Topologické uspořádání má časovou složitost $\mathcal{O}(|V| + |E|)$. V proceduře Pruning se hlavní cyklus (2--9) provádí $|V|$-krát a vnitřní cyklus (4--6) se provádí $|Adj[v]|$-krát. Protože $\sum_{v \in V}|Adj[v]| = |E|$, je časová složitost procedury Pruning $\mathcal{O}(|V| + |E|)$, z čehož plyne, že časová složitost algoritmu zanedbání stavů je $\mathcal{O}(|V| + |E|)$.
        \end{proof}

        \newpage

        \begin{algorithm}
            \label{algo:ZanedbaniStavu}
            \DontPrintSemicolon
            \caption{Zanedbání stavů}
            \KwIn{$G := (V, E)$}
            \KwOut{$G_{simply}$}
            \vspace*{0.5em}

            \SetKwProg{myalg}{Procedure}{}{}
                \myalg{\textnormal{Pruning($G_p:= (V_p, E_p)$)}}{
                    \For{$u \in \textnormal{Topological-sort}(G_p)$}
                    {
                        \If{$d_{p+}[u] = 0$}
                        {
                            \For{$v \in Adj_p[u]$}
                            {
                                $d_{p+}[v] \leftarrow d_{p+}[v] - 1$\;
                            }
                            $V_p.remove(u)$\;
                        }
                    }
                }{\textbf{end}}
            \vspace*{0.5em}

            $G_t \leftarrow G^T$ \tcp*{Transponujeme graf $G$}
            Pruning$(G_t)$ \tcp*{Smažeme zanedbatelné stavy v grafu $G_t$}
            $G_{simply} \leftarrow G_t^T$ \tcp*{Transponujeme graf $G_t$}
            Pruning$(G_{simply})$ \tcp*{Smažeme zanedbatelné stavy v grafu $G_{simply}$}
            \vspace*{0.5em}

            \KwRet{$G_{simply}$}

        \end{algorithm}

\chapter{Brute-force}
    \label{chapter:Algo1}
    \lipsum[1]

    \section{Popis algoritmu}
        Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut purus elit, vestibulum ut, placerat ac, adipiscing vitae, felis. Curabitur dictum gravida mauris. Nam arcu libero, nonummy eget, consectetuer id, vulputate a, magna. Donec vehicula augue eu neque.

        \begin{algorithm}[h]
            \SetAlgoLined
            \caption{Dummy Algorithm.}
            %
            Do something.\;
            \For{$k=0,1,2,3, ...$}{
                Do something.\;
                \eIf{$x \geq y$}{
                     Do something.\;
                }{
                     Do something.\;
                     \For{$j = 1,...,10$}{
                          Do something.\;
                     }
                     THIS IS THE SPOT WHERE I NEED THE PAGE BREAK.\;
                     Do something.\;
                }
            }
        \end{algorithm}

        \lipsum[1-2]

    \section{Časová složitost}
        \begin{theorem}
            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut purus elit, vestibulum ut, placerat ac, adipiscing vitae, felis. Curabitur dictum gravida mauris. Nam arcu libero, nonummy eget, consectetuer id, vulputate a, magna. Donec vehicula augue eu neque.
        \end{theorem}

        \begin{proof}
            \lipsum[1]
        \end{proof}

    \section{Prostorová složitost}
        \begin{theorem}
            Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Ut purus elit, vestibulum ut, placerat ac, adipiscing vitae, felis. Curabitur dictum gravida mauris. Nam arcu libero, nonummy eget, consectetuer id, vulputate a, magna. Donec vehicula augue eu neque.
        \end{theorem}

        \begin{proof}
            \lipsum[1]
        \end{proof}

\chapter{Herbert Weinbaltt}
    \label{chapter:Algo2}
    Tento algoritmus byl publikován v roce 1972 Herbertem Weinblattem \cite{A_new_search_algorithm}. Jeho základem je Tiernanův algoritmus \cite{Tiernan} publikovaný o dva roky dříve, který vyhodnocuje každý cyklus pouze jednou, jednalo se tedy o teoreticky nejefektivnější algoritmus, ovšem za cenu vyšších paměťových nároků. Sám Tiernan ale naznačil, že pro průměrně husté grafy s více než 100 hranami by bylo použití tohoto algoritmus neprakticky pomalé. Herbert Weinblatt ve svém článku popisuje nový přístup, který stejně jako Tiernanův vyhodnocuje každý cyklus pouze jednou, ale nově také minimalizuje množství prozkoumaných hran nutných k objevení cyklu. V důsledku toho dokázal algoritmus implementovaný v experimentálním jazyce Snobol3 na počítači IBM 7094 objevit všech 44 cyklů v grafu s 194 uzly a 294 hranami za méně než sedm sekund.

    \section{Popis algoritmu}
        Před vlastním popisem algoritmu je potřeba definovat pomocné funkce $\mathit{END}$ a $\mathit{TAIL}$.

        \begin{definition}
            \label{def:end}
            \textbf{END} je unární funkce, které pro cestu $\langle v_0 v_1 \dots v_n \rangle$, vrací poslední uzel cesty $v_n$.
        \end{definition}

        \begin{definition}
            \textbf{TAIL} je binární funkce, která pro dvojici uzlu $v_k$ a otevřenou cestu $\langle v_0 v_1 \dots v_k v_{k+1} \dots v_n \rangle$, respektive cyklus $\langle v_0 v_1 \dots v_k v_{k+1} \dots v_0 \rangle$ vrací podcestu $\langle v_{k+1} \dots v_n \rangle$, respektive $\langle v_{k+1} \dots v_0 \rangle$ s respektem k~uzlu $v_k$. V případě cyklu $\langle v_k v_{k+1} \dots v_k \rangle$ vrací prázdnou cestu $\langle \rangle$ délky 0.
        \end{definition}

        \vspace*{1em}
        V průběhu výpočtu využívá algoritmus seznam $TT$, který reprezentuje aktuální zkoumanou cestu. Dále jsou udržovány dvě pomocné struktury $S_v$ a $S_e$. Kde $S_v$ je pomocné pole udržující informaci, zda již byl uzel $v \in V$ v seznamu $TT$. $S_v[v]$ může nabývat hodnot 0, 1, nebo 2, což indikuje, že uzel $v$ ještě nebyl v seznamu $TT$, uzel $v$ se momentálně nachází v seznamu $TT$, nebo že uzel $v$ byl v $TT$, ale již se nenachází. Obdobná informace je udržována pro hrany. $S_e$ je matice informující, zda již byla hrana $(u, v) \in E$ v seznamu $TT$. $S_e[u][v]$ může nabývat pouze dvou hodnot, a to 0, respektive 2, což indikuje, že hrana $(u, v)$ ještě nebyla v $TT$, respektive že hrana $(u, v)$ již byla v $TT$ a stále může být.

        Pro sjednocení dvou cest $P_1 = \langle v_1v_2 \rangle$ a $P_2 = \langle v_3v_4 \rangle$ bude využíván operátor $+$, tedy $P_1 + P_2 = \langle v_1v_2v_3v_4 \rangle$.

        \begin{algorithm}
            \DontPrintSemicolon
            \caption{Herbert Weinbalttův algoritmus}
            \KwIn{$G := (V, E), n:= |V|$}
            \KwOut{$L_{cycles}$}
            \vspace*{0.5em}

            \SetKwProg{myalg}{Procedure}{}{}
                \myalg{\textnormal{CONCAT($isRecursion, Path$)}}{
                    \tcp*[h]{Inicializace lokálních proměnných}\;
                    $cycleTails \leftarrow  \mathit{EmptyList}$\;
                    $toAddSave \leftarrow \mathit{EmptyList}$\;
                    $toAddToControl \leftarrow  \mathit{EmptyList}$\;
                    $added \leftarrow  \mathit{EmptyList}$\;
                    $v \leftarrow \textnormal{END}(Path)$\;
                    \vspace*{0.5em}

                    \For{$cycle \in L_{cycles}$}
                    {
                        $tail \leftarrow \textnormal{TAIL}(v, cycle)$\;
                        \If{$tail = \emptyset \lor tail \in L_{cycles}$}
                        {
                            \textbf{continue}\;
                        }
                        $cycleTails.append(tail)$\;
                        \If{$\exists v_k \in tail: v_k \in Path$}
                        {
                            \textbf{continue}\;
                        }
                        $cycleEnd \leftarrow \textnormal{END}(cycle)$\;
                        \eIf{$S_v[cycleEnd] = 2$}
                        {
                            $toAddToControl.extend(\textnormal{CONCAT}(\mathbf{True}, Path + tail))$\;
                            \textbf{continue}\;
                        }
                        {
                            $\begin{aligned}newCycle \leftarrow &\langle cycleEnd \rangle + \textnormal{TAIL}(cycleEnd, TT) + \\[-1mm]
                                                       &Path + \textnormal{TAIL}(\textnormal{END}(Path), cycle)\end{aligned}$\;
                            \eIf{$isRecursion$}
                            {
                                $toAddToControl.append(newCycle)$\;
                            }
                            {
                                $toAddSave.append(newCycle)$\;
                            }
                        }

                    }
                    \vspace*{0.5em}

                    \eIf(){$isResursion$}
                    {
                        \KwRet{$toAddToControl$}
                    }
                    {
                        $L_{cycles}.extend(toAddSave)$\;
                        $added.extedn(toAddSave)$\;
                        \For{$cycle \in toAddToControl$}
                        {
                            \If{$cycle \notin added$}
                            {
                                $L_{cycles}.append(cycle)$\;
                                $added.append(cycle)$\;
                            }
                        }
                    }
                }{\textbf{end}}
            \vspace*{0.5em}

        \end{algorithm}

        \newpage

        \setlength{\algotitleheightrule}{0pt}
        \begin{algorithm*}[!h]
            \DontPrintSemicolon
            \setcounter{AlgoLine}{41}
            \SetKwProg{myalg}{Procedure}{}{}
                \myalg{\textnormal{EXAMINE($v$)}}{
                    \uIf{$S_v[v] = 0$}
                    {
                        $S_v[v] \leftarrow 1$\;
                        $TT.append(v)$\;
                    }
                    \uElseIf{$S_v[v] = 1$}
                    {
                        $L_{cycles}.append(\langle v \rangle + \textnormal{TAIL}(v, TT) + \langle v \rangle)$\;
                    }
                    \uElse
                    {
                        CONCAT$(\mathbf{False}, [v])$\;
                    }
                }{\textbf{end}}
            \vspace*{0.5em}

            \SetKwProg{myalg}{Procedure}{}{}
                \myalg{\textnormal{EXTEND}}{
                    \While{$TT \neq \emptyset$}
                    {
                        $u \leftarrow \mathnormal{END}(TT)$\;
                        $possible\_v \leftarrow \{v \in V \,|\, (u, v) \in E \land  S_e[u][v] = 0\}$\;
                        \eIf{$possible\_v = \emptyset$}
                        {
                            $S_v[u] \leftarrow 2$\;
                            $TT.removeLast()$\;
                        }
                        {
                            $v \leftarrow PickOne(possible\_v)$\;
                            $S_e[u][v] \leftarrow 2$\;
                            EXAMINE($v$)\;
                        }
                    }
                }{\textbf{end}}
            \vspace*{0.5em}

            \tcp*[h]{Inicializace globálních proměnných}\;
            $TT \leftarrow \mathit{EmptyList}$\;
            $S_e[0 \dots n-1][0 \dots n-1] \leftarrow 0$ \tcp*{nulová matice $n \times n$}
            $S_v[0 \dots n-1] \leftarrow 0$\;
            \vspace*{0.5em}

            \For{$v \in V$}
            {
                \If{$S_v[v] = 0$}
                {
                    $S_v[v] \leftarrow 1$\;
                    $TT.append(v)$\;
                    EXTEND()\;
                }
            }

            \KwRet{$L_{cycles}$}

        \end{algorithm*}
        \setlength{\algotitleheightrule}{\algotitleheightruledefault}

        Před spuštěním prohledávání grafu jsou všechny uzly, pro které se může hodnota $d_+$ nebo $d_-$ rovnou nule zanedbány (odstraněny) algoritmem \ref{algo:ZanedbaniStavu}. Cílem tohoto kroku je eliminovat uzly, které nemohou tvořit cykly a tím snížit velikost grafu nad kterým bude prohledávání prováděno.

        Algoritmus náhodně vybere jeden uzel grafu (\textit{počáteční uzel cesty}) a začne prozkoumávat všechny cesty vycházející z tohoto uzlu. Pokud se během vytváření cesty některý uzel navštíví vícekrát, je tato podcesta označena za cyklus a konstrukce cyklu se navrátí k předchozímu uzlu, pro který existují doposud neprozkoumaní následníci. Pokud již žádný takový následník neexistuje, zvolí algoritmus nový, doposud nezvolený, \textit{počáteční uzel cesty}. V případě, že takový uzel neexistuje, algoritmus skončí.

        V průběhu výpočtu je cesta vedoucí z \textit{počátečního uzlu cesty} reprezentovaná seznamem $TT$ ("trial thread"). Při návratu je odstraněn poslední uzel (nejvzdálenější od \textit{počátečního uzlu}) cesty $TT$.

        Když algoritmus dospěje k uzlu $v$, který již byl v minulosti vyhodnocován, pak před zpětným navrácením provede kontrolu, zda některá z doposud vyhodnocovaných hran netvoří nový cyklus. Pokud se uzel $v$ nachází v $TT$, pak existuje právě jeden cyklus, který je tvořen sjednocením $v$ s \textit{TAIL} $TT$ s respektem k uzlu $v$. Pokud se uzel $v$ již nenachází v $TT$, pak může cyklus existovat pouze tehdy, pokud již byly dříve nějaké cykly obsahující $v$ objeveny. V takovém případě je spuštěna rekurzivní procedura CONCAT, která se snaží nalézt cestu, která začíná na uzlu $v$ a končí na některém uzlu $u$, který je stále na $TT$. Z každé takto nalezené cesty je vytvořen cyklus sjednocením této cesty s \textit{TAIL} $TT$ respektujícím $u$. (Nechť $C_1 = \langle v_1v_2v_1 \rangle$ a $C_2 = \langle v_2v_3v_2 \rangle$ jsou dva již objevené cykly, $TT = \langle v_1 \rangle$ a algoritmus objeví již jednou zpracovaný uzel $v_3$. V takovém případě je konkatenací podcesty $\langle v_1 \rangle$ z $TT$, podcesty $\langle v_3v_2 \rangle$ z $C_2$ a podcesty $\langle v_1 \rangle$ z $C_1$ vytvořen nový cyklus $\langle v_1v_3v_2v_1 \rangle$.)

    \section{Časová složitost}
        \begin{theorem}
            Časová složitost Herbert Weinblattova algoritmu pro výčet všech cyklů v orientovaném grafu je $\mathcal{O}(|V|^2 + |E|\cdot|V|\cdot(c + 1))$, kde $c$ je počet cyklů v grafu.
        \end{theorem}

        \begin{proof}
            Imicializace glogálních proměnných (65--67) má časovou složitost $\mathcal{O}(|V|^2)$. Časová složitost zanedbání uzlů je $\mathcal{O}(|V| + |E|)$. Hlavní cyklus (68--74) a zavolání procedury EXTEND bude provedeno nejvýše $|V|$-krát. Cyklus (62--63) v proceduře EXTEND a vykonání procedury EXAMINE bude provedeno nejvýše $|E|$-krát, protože podmínkou pro neprázdnost $possible\_v$ je, že existuje hrana $(u, v) \in E$, pro který je $S_e[u][v] = 0$. Pro vybranou hranu $(u, v)$ je následně nastaveno $S_e[u][v]$ na hodnotu $2$. Časová složitost bez procedury CONCAT je $\mathcal{O}(|V|^2 + |E|)$.

            Nerekurzivní volání procedury CONCAT (49) je uskutečněno maximálně $|E|$-krát, protože je provedeno z procedury EXAMINE. Hlavní cyklus (7--28) procedury CONCAT je proveden pro každý cyklus stejně jako cyklus pro odstranění duplikátů (34--39). Procedura CONCAT může být volána rekurzivně pro každý vrchol nejvýše jednou kvůli podmínce (17) $S_v[cycleEnd] = 2$. Volání procedůry CONCAT tak má časovou složitost $\mathcal{O}(c \cdot |E| \cdot |V|)$.

            Celková složitost algoritmu je tedy $\mathcal{O}(|V|^2 + |E|\cdot|V|\cdot(c + 1))$. Hodnota $c + 1$ je použita pro případy, kdy $c = 0$. I v takových případech totiž bude provedeno prohledávání.
        \end{proof}

    \section{Prostorová složitost}
        \begin{theorem}
            Prostorová složitost Herbert Weinblattova algoritmu pro výčet všech cyklů v orientovaném grafu je $\mathcal{O}(c * |V| + |V|^2)$, kde $c$ je počet cyklů v grafu.
        \end{theorem}

        \begin{proof}
            Algoritmus využívá tři globální pomocné struktury. Prostorová složitost $TT$ je $\mathcal{O}(|V|)$ protože maximální délka cyklu je shora omezena na $|V| + 1$. Prostorová složitost matice $S_e$ je $\mathcal{O}(|V|^2)$. A prostorová složitost pole $S_v$ je $\mathcal{O}(|V|)$. Prostorovou složitost lokálních pomocných proměnných $added$, $cycleTails$, $toAddSave$ a $toAddToControl$ můžeme zanedbat, protože jejich data jsou obsažena v listu všech detekovaných cyklů $L_{cycles}$. Prostorová složitost listu $L_{cycles}$ je $\mathcal{O}(c * |V|)$, protože obsahuje $c$ cyklů, kde délka cyklu může být až $|V| + 1 \approx |V|$.

            Pokud by prohledávaný graf neobsahoval žádný cyklus, potom budou vždy inicializovány globální pomocné struktury s prostorovou složitostí $\mathcal{O}(|V|^2)$.

            Bylo dokázáno, že prostorová složitost Herbert Weinblattova algoritmu pro výčet všech cyklů v orientovaném grafu je $\mathcal{O}(c * |V| + |V|^2)$, kde $c$ je počet cyklů v grafu.
        \end{proof}

\chapter{Hongbo Liu a Jiaxin Wang}
    \label{chapter:Algo3}
    V roce 2006 spolu Hongo Liu a Jiaxin Wang publikovali algoritmus \cite{A_new_way_to_enumerate_cycles_in_graph} pro výčet všech cyklů v grafech. Tento algoritmus není tak efektivní jako algoritms Johnsona \cite{Johnson_1975}. V porovnáni s nimi je ale jednodušší pro porozumění, čímž jsou minimalizovány chyby v implementaci způsobené chybnou interpretací. Na druhou stranu Liuův a Wangův přístup je neefektivní pro velké grafy. Nicméně existují případy, pro které je jejichž řešení efektivnější.

    Algoritmus využívá frontu zkoumaných cest $P_0 \dots P_n$ pro $n \in \mathbb{N}_0$, kde pro délky cest ve frontě platí $|P_n| \leq |P_0| + 1$ a zároveň $|P_{i-1}| \leq |P_{i}|$. Díky tomu jej lze snadno využít pro výčet všech cyklů délek maximálně $k \in \mathbb{N}_0$ be z nutnosti nalezení všech cyklů.

    \section{Popis algoritmu}
        Algoritmus využívá pomocné funkce \textit{END}, která již byla definována dříve \ref{def:end} a \textit{HEAD}.

        \begin{definition}
            \textbf{HEAD} je unární funkce, které pro cestu $\langle v_0 v_1 \dots v_n \rangle$, vrací první uzel cesty $v_0$.
        \end{definition}

        \vspace*{1em}
        Pro sjednocení dvou cest $P_1 = \langle v_1v_2 \rangle$ a $P_2 = \langle v_3v_4 \rangle$ budeme využívat operátor $+$, tedy $P_1 + P_2 = \langle v_1v_2v_3v_4 \rangle$.

        Aby se zabránilo duplicitní detekci cyklů, které byly generovány z jiných počátečních uzlů, ale jinak jsou si zcela ekvivalentní, je každému uzlu $v$ přiřazena různá hodnota $ord(v) \in \mathbb{N}_0$, kde pro $u, v \in V$ platí $ord(u) = ord(v) \iff u = v$. Při prohledávání cesty $P$ v grafu pak může být uzel $v$ připojen na konec cesty $P$ pouze pokud $ord(v) > ord(\textit{HEAD}(P))$.

        Před spuštěním prohledávání grafu jsou všechny uzly, pro které se může hodnota $d_+$ nebo $d_-$ rovnou nule zanedbány (odstraněny) algoritmem \ref{algo:ZanedbaniStavu}. Cílem tohoto kroku je eliminovat uzly, které nemohou tvořit cykly a tím snížit velikost grafu nad kterým bude prohledávání prováděno.

        Při inicializaci proměnných (1--4) jsou všechny cesty délek 0 vloženy do fronty cest $Q$. V hlavním cyklu (5--19) se algoritmus snaží vytvořit cykly délky $k$ pro cesty délek $k-1$. Cyklus délky $k$ je tvořen sjednocením cesty $P$ délky $k-1$ a hrany $(\textit{END}(P), \textit{HEAD}(P))$. Z cesty $P$ jsou dále na základě přechodů vedoucích z $\textit{END}(P)$ vygenerovány nové cesty $P + \langle v \rangle$ pro $v \in \{v \in Adj[\textit{END}(P)] \,|\, v \notin P \land ord(v) > ord(\textit{HEAD}(P))\}$ vloženy do fronty cest $Q$.

        Pokud je fronta cest $Q$ prázdná (nebylo již možné vygenerovat další cesty), je algoritmus ukončen a všechny objevené cykly jsou vráceny v seznamu $L_{cycles}$.

        \newpage

        \begin{algorithm}
            \DontPrintSemicolon
            \caption{Liuův a Wangův algoritmus}
            \KwIn{$G := (V, E)$}
            \KwOut{$L_{cycles}$}
            \vspace*{0.5em}

            \tcp*[h]{Inicializace}\;
            $Q \leftarrow EmptyQueue$\;
            \For{$v \in V$}
            {
                $\mathit{ENQUEUE}(Q, \langle v \rangle)$\;
            }
            \vspace*{0.5em}

            \While{$Q \neq \emptyset$}
            {
                $P \leftarrow \mathit{DEQUEUE}(Q)$\;
                $head \leftarrow \mathit{HEAD}(P)$\;
                $end \leftarrow \mathit{END}(P)$\;
                \For{$v \in Adj[end]$}
                {
                    \uIf{$v = head$}
                    {
                        $L_{cycles}.append(P + \langle v \rangle)$\;
                    }
                    \ElseIf{$ord(v) > ord(head)$}
                    {
                        \If{$v \notin P$}
                        {
                            $\mathit{ENQUEUE}(Q, P + \langle v \rangle)$\;
                        }
                    }
                }
            }
            \vspace*{0.5em}

            \KwRet{$L_{cycles}$}

        \end{algorithm}

    \section{Časová složitost}
        \begin{theorem}
            Časová složitost algoritmu, který publikovali Hongo Liu a Jiaxin Wang je $\mathcal{O}(d^{|V|-d}\cdot d!)$, kde $d = max_{v\in V}(d_-(v))$ je maximální výstupní stupeň v grafu.
        \end{theorem}

        \begin{proof}
            Časová složitost zanedbání uzlů je $\mathcal{O}(|V| + |E|)$. Inicializace a naplnění fronty (1--4) $Q$ má časovou složitost $\mathcal{O}(|V|)$. Halvní cyklus (5--18) bude proveden tolikrát, kolik existuje cest $P$ odpovídajících podmínce  $\forall v \in P: ord(v) \geq ord(HEAD(P))$. Takových cest cest existuje $X$, kde

            $$
            X = \sum_{n = 1}^{|V|}(d-1)^\alpha\cdot(\beta -1)!
            $$

            \noindent $\alpha = \frac{|n - d| + n - d}{2}$ a $\beta = min(d, n)$. Pokud se $d$ blíží $|V|$, pak $X \approx d!$. Pokud se $d$ blíží 1, pak $X \approx d^{|V|}$. Časová složitost algoritmu je tedy $\mathcal{O}(d^{|V|-d}\cdot d!)$.

        \end{proof}

    \section{Prostorová složitost}
        \begin{theorem}
            Prostorová složitost algoritmu, který publikovali Hongo Liu a Jiaxin Wang je $\mathcal{O}(d^{|V|-d}\cdot d!)$, kde $d = max_{v\in V}(d_-(v))$ je maximální výstupní stupeň v grafu.
        \end{theorem}

        \begin{proof}
            Prostorová složitost výstupního seznamu $L_{cycles}$ je $\mathcal{O}(c * |V|)$, protože délka cyklu může být až $|V| + 1 \approx |V|$. Do fronty $Q$ se postupně ukládají všechny cesty v grafu. Do fronty může být celkem uloženo $X$ cest, kde

            $$
            X = \sum_{n = 1}^{|V|}(d-1)^\alpha\cdot(\beta -1)!
            $$

            \noindent $\alpha = \frac{|n - d| + n - d}{2}$ a $\beta = min(d, n)$. Součet všech délek všech $X$ cest je

            $$
            Y = \sum_{n = 1}^{|V|}(d-1)^\alpha*(\beta -1)! \cdot n
            $$

            \noindent Obsah sumy dosahuje maxima pro $n = |V|$. Pokud se $d$ blíží $|V|$, pak $Y \approx d!$. Pokud  se $d$ blíží 1, pak $Y \approx d^{|V|}$. Lze vidět, že prostorová složitost algoritmu je definována prostorovou složitostí fronty. Prostorová složitost algoritmu je tedy $\mathcal{O}(d^{|V|-d}\cdot d!)$.
        \end{proof}

\chapter{Návrh programu}
    \label{chapter:Design}
    Tato kapitola popisuje jednotlivé komponenty, z nichž sestává program pro výčet všech cklů v orientovaných grafech využívající zmíněné algoritmy. Veškerá implementace byla provedena v~jazyce Python 3 (verze 3.8+) s využitím knihoven (Bidict\footnote{Bidict dostupné z: \url{https://bidict.readthedocs.io}}, Networkx\footnote{Networkx dostupné z: \url{https://networkx.org}} a Numpy\footnote{Numpy dostupné z: \url{https://www.numpy.org}}).

    \section{Moduly}
        Za účelem zapouzdření jsou veškeré algoritmy a třídy umístěny do balíku \texttt{gal}. Ten obsahuje modul \texttt{digraph}, ve kterém se nachází definice třídy orientovaných grafů \texttt{DiGraph}, modul modul \texttt{parser} s třídou \texttt{Parser}, která slouží pro získání orientovaného grafu ze vstupního souboru a modul \texttt{algorithms}, který obsahuje definice jednotlivých algoritmů pro výčet všech cyklů.

        \subsection{digraph}
            Třída grafů disponuje základními metodami pro práci s grafy, jakými jsou přidávání uzlů (\texttt{add\_vertex}), přidávání hran (\texttt{add\_edge}), transponování (\texttt{transpose}), získání indukovaného grafu (\texttt{get\_induced\_graph}), výpočet DFS lesa (\texttt{dfs}) nebo získání topologického uspořádání (\texttt{get\_topological\_sort}).

            Pro zjednodušení interní reprezentace uzlů a pokrytí funkce \textit{ord} využívané v algoritmech jsou uzly reprezentovány číselnou hodnotou, kde pro dva uzly $u, v \in V$ platí $ord(u) = ord(v) \iff u = v$. Informace o původním jménu uzlu je uložena v obousměrném slovníku \texttt{vertex\_cname}.

            Třída \texttt{DiGraph} poskytuje možnost generování úplných grafů (\texttt{create\_complete\_graph}), multi-cyklických grafů (\texttt{create\_multicycle\_graph}) a v poslední řadě takzvaných nested grafů (\texttt{create\_nested\_graph}). Tyto generované grafy byly použity pro testování a  při získávání experimentálních výsledků.

            \begin{definition}
                Nechť $G = (V, E)$ je orientovaný graf. $G$ se nazývá \textbf{úplný orientovaný graf}, pokud $E = V \times V$.
            \end{definition}

            \begin{definition}
                Nechť $G = (V, E)$ je orientovaný graf. $G$ se nazývá \textbf{multi-cyclický orientovaný graf}, pokud $|E| > |V|$ a zároveň existuje v grafu cyklus $C = \langle v_1v_2 \dots v_n \rangle$, kde $|C| = |V| + 1$.
            \end{definition}

            \newpage

            \begin{figure}
                \centering
                  \begin{tikzpicture}[node distance=2cm]
                    \node[state] (v0) {$v_0$};
                    \node[state, above right of=v0] (v1) {$v_1$};
                    \node[state, right of=v1] (v2) {$v_2$};
                    \node[state, below right of=v2] (v3) {$v_3$};
                    \node[state, below right of=v0] (v5) {$v_5$};
                    \node[state, right of=v5] (v4) {$v_4$};
                    \draw[->]
                        (v0) edge[] node{} (v1)
                        (v1) edge[] node{} (v2)
                        (v1) edge[] node{} (v3)
                        (v2) edge[] node{} (v3)
                        (v3) edge[] node{} (v4)
                        (v4) edge[] node{} (v0)
                        (v4) edge[] node{} (v5)
                        (v5) edge[] node{} (v2)
                        (v5) edge[] node{} (v0);
                \end{tikzpicture}
                \caption{Multi-cyklický orientovaný graf.}
            \end{figure}

            \begin{definition}
                Nechť $G = (V, E)$ je orientovaný graf. $G$ se nazývá \textbf{nested orientovaný graf}, pokud $E = \{(u, v) \,|\, ((u, m), (v, n)) \in (V \triangledown \mathbb{N})^2 \land\, n < m\}$, kde $\triangledown$ je diagonální produkt\footnote{Produkuje pouze dvojice prvků ležící na diagonále množinového produktu.}.
            \end{definition}

            \begin{figure}[!h]
                \centering
                  \begin{tikzpicture}[node distance=2cm]
                    \node[state] (v3) {$v_3$};
                    \node[state, right of=v3] (v2) {$v_2$};
                    \node[state, right of=v2] (v1) {$v_1$};
                    \node[state, right of=v1] (v0) {$v_0$};
                    \draw[->]
                        (v3) edge[] node{} (v2)
                        (v2) edge[] node{} (v1)
                        (v1) edge[] node{} (v0)

                        (v2) edge[bend right] node{} (v0)
                        (v3) edge[bend left=30] node{} (v1)
                        (v3) edge[bend left=40] node{} (v0);
                \end{tikzpicture}
                \caption{Nested orientovaný graf.}
            \end{figure}

        \subsection{parser}
            Třída \texttt{Parser} poskytuje statickou metodu pro načítání grafů ze vstupních souborů. Tato metoda vrací instanci třídy \texttt{DiGraph}. Vstupní soubor obsahuje na každém řádku jednu hranu. Hrana je reprezentován dvojici vrcholů oddělených mezerou. Jména vrcholů mohou obsahovat pouze alfanumerické znaky.

            \vspace*{1em}
            \noindent \underline{Příklad formátu grafu} $G = (\{v_0, v_1, v_2\}, \{(v_0, v_1), (v_1, v_2), (v_2, v_0)\})$:
            \vspace*{0.5em}\\
            \noindent\texttt{
                v0 v1\\
                v1 v2\\
                v2 v0\\
            }

        \subsection{algorithms}
            Modul \texttt{algorithms} obsahuje implementace jednotlivých algoritmů pro výčet cyklů v grafech. Pro porovnání je zde také použita knihovna Networkx. Jednotlivé implementace nejsou k dispozici přípo, ale přez volání funkce \texttt{get\_cycles}, která na základě specifikovaného prametru \texttt{algo} vybere, zda bude použit algoritmus z knihovny Networkx \cite{Johnson_1975} (\texttt{algo="nx"}), brute-force algorithmus \cite[str. 287]{Book_algo} (\texttt{algo="bf"}), Herbert Weinbalttův algoritmus \cite{A_new_search_algorithm} (\texttt{algo="wein"}), nebo algoritmus Hongo Liu a Jiaxin Wanga \cite{A_new_way_to_enumerate_cycles_in_graph} (\texttt{algo="hj"}).

    \newpage

    \section{Použité knihovny}
        Program využívá knihovny Networkx (verze 2.8.7) pro porovnánání efektivity implementovaných algoritmů pro výčet všech cyklů v grafu, knihovnu Bidict (verze 0.22.0) implementující obousměrný slovník využívaný pro obousměrný překlad jmen uzlů na jejích pořadové čísla a knihovnu Numpy (verze 1.23.3) k reprezentaci matic. Tyto závislosti lza nainstalovat pomocí nástroje pip3.

        Dále je využita knihovna Argparse, pro zpracování argumentů příkazové řádky, která je ale součásti stendartních knihoven python již od verze 3.2.

\chapter{Použití programu}
    \label{chapter:Help}
    V této kapitole je popsána struktura složky projektu. Dále je uveden postup pro instalaci knihoven (Bidict\footnote{Bidict dostupné z: \url{https://bidict.readthedocs.io}}, Networkx\footnote{Networkx dostupné z: \url{https://networkx.org}} a Numpy\footnote{Numpy dostupné z: \url{https://www.numpy.org}}) využívaných programem. Kapitola také uvádí nápovědu pro spuštění programu pomocí interpretu Python 3 včetně vzorového formátu vstup a výstupu, po kterých následují příklady jednotlivých možností spuštění. Na závěr kapitoly jsou popsány automatické testy, který byly při implementaci použity.

    \section{Struktura projektu}
        Na kořenové úrovni projektu se nachází tři složky. Složka \texttt{/src} obsahuje modul \texttt{gal} a spustitelný program \texttt{enum\_cycles.py}. Příklady grafů spolu s nulticyklickými grafy využitými při experimentech se nachází ve složce \texttt{/graphs}. Tato dokumentace je umístěná ve složce \texttt{/doc}. Na kořenové úrovni projektu se také nachází soubor \texttt{requirements.txt} obsahující využívané knihovny a jejich verze. Skript s automatickými testy pro modul \texttt{gal} je umístěn ve složce \texttt{/tests}.

    \section{Instalace závislostí}
        Potřebné knihovny využívané programem lze instalovat pomocí vástroje pip3 do virtuálního prostředí následovně.

        \vspace*{1em}
        \noindent\texttt{python3 -m venv gal-env\\
            source ./gal-env/bin/activate\\
            pip3 install -r requirements.txt
        }

    \section{Spuštění programu}
        Při spuštení programu lze přepínači zvolit algoritmus, který bude použit pro výčet všech cyklů v zadaném grafu. Lze vybírat mezi algoritmem z knihovny Networkx, brute-force algoritmem, algoritmem Hongbo Liu a Jiaxin Wanga, nebo algoritmem Herberta Weinblatta. Musí být zadán přávě jeden přepínač určující algoritmus.

        Dále lze zpracovávat graf zadaný vstupním souborem, nebo vygenerovaný (úplný, multi-cyklický, nebo nested) třídou \texttt{DiGraph}. Právě jeden vstupní graf musí být zadán.

        Program \texttt{enum\_cycles.py} umístěný ve složce \texttt{/src} lze po úspěšné instalaci závislostí spustit s využitím interpretu python3 (verze 3.8+) následovně:

        \vspace*{1em}
        \noindent\texttt{enum\_cycles.py (-{}-nx | -{}-bf | -{}-hj | -{}-wein) [-c N] [-m N M] [-n N] [input]\\
        \\
        poziční argumenty:\\
        \hspace*{0.5em}input\hspace*{11em}Vstupní soubor s grafem.\\
        \\
        přepínače:
        \vspace*{1em}\\
        \begin{tabular}{lll}
            -h, &-{}-help& Zobrazí tuto nápovědu.\\
            -{}-nx&& Použije algoritmus z knihovny Networkx.\\
            -{}-bd&& Použije brute-force algoritmus.\\
            -{}-hj&& Použije algoritmus Hongbo Liu a Jiaxin Wanga.\\
            -{}-wein&& Použije algoritmus Herberta Weinblatta.\\
            -c N, &-{}-complete N& Spustí výčet cyklů nad úplným grafem s N uzly.\\
            -m N M, &-{}-multicycle N M& Spustí výčet cyklů nad multi-cyklickým grafem\\
            &&s N uzly a X hranami, kde X se blíží N+M.\\
            -n N, &-{}-nested N& Spustí výčet cyklů nad nested grafem s N uzly.
        \end{tabular}
        }

    \section{Formát vstupu}
        \label{sec:input}
        Vstupní soubor s příponou \texttt{.grph} obsahuje orientovaný graf. Každý řádek souboru reprezentuje jednu hranu. Uzel z kterého hrana vystupuje a uzel, do kterého vede jsou na řádku odděleny mezerou. Jména uzlu mohou sestávat z alfanumerických znaků. V tomto formátu jsou brány v úvahu pouze ty uzly grafu, pro které existuje hrana. Podpora pro izolované uzly bez hran není inplementována (tyto uzly nikdy nemohou být součástí cyklu).

        \vspace*{1em}
        \noindent \underline{Příklad vstupního grafu:}
        \vspace*{0.5em}\\
        \noindent\texttt{
            v0 v0\\
            v0 v1\\
            v1 v2\\
            v2 v0
        }

    \section{Formát výstupu}
        Všechny nalezené cykly jsou vypsány na \texttt{STDOUT}. Na každém řádku se nachází právě jeden cyklus. Cyklus je reprezentován posloupností vrcholu oddělených mezerou. Poslední uzel cyklu, který je shodný s počátečním uzlem není uváděn (po vzoru knihovny Networkx).

        Následující přiklad výstupu je výsledkem prohledávání grafu uvedeného v předchozí sekci \ref{sec:input}.

        \vspace*{1em}
        \noindent \underline{Příklad výstupu:}
        \vspace*{0.5em}\\
        \noindent\texttt{
            v0\\
            v0 v1 v2
        }

    \section{Příklady spuštění}
        Tato sekce uvádí vybrané přiklady spuštění programu.

        \subsection*{Networkx + vstupní soubor}
            \texttt{python3 enum\_cycles.py -{}-nx g.grph}

            \vspace*{0.5em}
            Program provede výčet včech cyklů nad grafem uvedeném v souboru \texttt{g.grph} s využitím algoritmu z knihovny Networkx.

        \subsection*{Brute-Force + úplný graf}
            \texttt{python3 enum\_cycles.py -{}-bf -c 6}

            \vspace*{0.5em}
            Program provede výčet všech cyklů nad úplným grafem $G_c = (V, E)$, kde $|V| = 6$ s využitím brute-force algoritmu (\ref{chapter:Algo1}).

        \subsection*{Hongbo Liu a Jiaxin Wang + multi-cyklický graf}
            \texttt{python3 enum\_cycles.py -{}-hj -m 10 5}

            \vspace*{0.5em}
            Program provede výčet všech cyklů nad multi-cyklickým grafem $G_m = (V, E)$, kde $|V| = 10$ a $|E| \rightarrow 10 + 5$ s využitím Hongbo Liu a Jiaxin Wangovým algoritmem (\ref{chapter:Algo2}).

        \subsection*{Herbert Weinblatt + nested graf}
            \texttt{python3 enum\_cycles.py -{}-bf -n 9}

            \vspace*{0.5em}
            Program provede výčet všech cyklů nad nested grafem $G_n = (V, E)$, kde $|V| = 9$ s využitím Herbert Weinblattova algoritmu (\ref{chapter:Algo3}). Výsledkem tohoto prohledávání musí být vždy 0 cyklů.

    \section{Automatické testy}
        Při vývoji modulu \texttt{gal} byl použit skript \texttt{run\_tests.py} s automatickými testy, který je umístěn ve složce \texttt{/tests}. Testy jsou prováděny na úplných grafech pro $|V| \in \langle 1, 6 \rangle$, multy-cyklických grafech pro kombinace $|V| \in \langle 1, 20 \rangle$ a $|E| \in \langle |V|, |V| + 20 \rangle$ a na nested grafech pro $|V| \in \langle 1, 100 \rangle$. Za referenční výsledky jsou zvoleny cykly, které jsou objeveny pomocí knihovny Networkx.

        Za účelem vyžší přehlednosti je během testování tištěna informace o počtu provedených testů pomocí knihovny \texttt{tqdm}\footnote{Tqdm dostupné z: \url{https://tqdm.github.io}} (verze 4.64.1). Tato knihovna se souběžně instaluje se závislostmi pro program \texttt{enum\_cycles.py}.


\chapter{Experimenty}
    \label{chapter:Experiments}
    Tato kapitola popisuje výsledky experimentálních měření pro studované algoritmy výčtu cyklů v orientovaných grafech. Za účelem testování byly zvoleny úplné grafy a mulit-cyklické grafy. Během implementace programu se ukázalo, že nested grafy nejsou vhodné pro porovnávání algoritmu (všechny algoritmy byly stejně efektivní). Z tohoto důvodu byly nested grafy použity pouze pro testování.

    Úplné grafy byly vybrány z důvodu své vysoké komplexnosti, navíc jsou často používané jako hlavní měřítko efektivity algoritmů pro výčet cyklů.

    Multi-cyklické grafy slouží k simulování prohledávání nad řidkými grafy obsahujícími cykly. Hlavním cílem tohoto porovnávání je zjistit, jak se bude měnit efektivita jednotlivých algoritmu s rostoucí hustotou (počtem hran) grafu pro fixní počet uzlů (200).

    Měření byla prováděna na procesoru AMD Ryzen 7 3800XT (3.9 GHz) s 8 jádry a 16 vláky a 32 GB RAM.

    Experimenty se zaměřovaly na množství času a paměti spotřebované jednotlivými algoritmy. Tyto hodnoty jsou zobrazeny v následujících tabulkách, kde jsou uvedeny pouze zkratky pro jednotlivé algoritmy (NX pro algoritmus knihovny Networkx, BF pro Brute-Force algoritmus, WEIN pro Herberta Weinblattův algoritmus, HJ pro algoritmus Hongbo Liu a Jiaxin Wanga).

    Pokud zkoumaný algoritmus nedokázal vyhledat všechny cykly v zadaném orientovaném grafu do 3 minut, byl ukončen a další testování na obtížnějších grafech již nebylo prováděno (prázdné buňky tabulek).

    \section{Úplné grafy}
        V této sekci jsou porovnány reálné časové a poměťové nároky algoritmů výčtu cyklů pro úplné grafy. Úplné grafy představují nejkomplexnější grafovou strukturu a proto jsou často používané jako hlavní měřítko efektivity algoritmů pro výčet cyklů. Úplný orientovaný graf o $|V| =: n$ vrcholech obsahuje $\sum_{i=1}^n \frac{n!}{(n-i)! \cdot i}$ cyklů.

        Časová složitost algoritmu WEIN roste v porovnání s algoritmy NX a HJ mnohonásovně rychleji. Úplné grafy obsahující 8 vrcholů již není možné algoritmem WEIN prohledat v časovém limitu tří minut.

        Z tabulky lze vidět, že časová složitost NX a HJ je pro úplné grafy podobná, i když poměř časů HJ a NX pro úplný graf o 5-ti vrcholech je $0.48$, ale pro graf s 11-ti vrcholy již $0.66$, z čehož lze pozorovat, že od určitého počtu vrcholů/cyklů začíná časová složitost algoritmu HJ růst rychleji než NX. Obdobné tvrzení lze vyvodit i pro paměťové nároky algoritm HJ.

        \begin{table}[!h]
            \centering
            \begin{tabular}{|| l | r || r | r | r | r || r | r | r | r ||}
                \hline
                \multicolumn{2}{|| c ||}{} & \multicolumn{4}{c ||}{Čas [s]} & \multicolumn{4}{c ||}{Paměť [MiB]}\\
                \hhline{==========}
                \multicolumn{1}{|| c}{$|V|$} & \multicolumn{1}{| c ||}{\# cyklů} & \multicolumn{1}{c |}{NX} & \multicolumn{1}{c |}{BF} & \multicolumn{1}{c |}{WEIN} & \multicolumn{1}{c ||}{HJ} & \multicolumn{1}{c |}{NX} & \multicolumn{1}{c |}{BF} & \multicolumn{1}{c |}{WEIN} & \multicolumn{1}{c ||}{HJ} \\
                \hhline{==========}
                1 & 1 & 0.23 & --- & 0.11 & 0.11 & 68.6 & --- & 40.0 & 40.1 \\
                \hline
                2 & 3 & 0.23 & --- & 0.11 & 0.11 & 68.3 & --- & 40.0 & 39.9 \\
                \hline
                3 & 8 & 0.23 & --- & 0.11 & 0.11 & 68.4 & --- & 39.9 & 39.9 \\
                \hline
                4 & 24 & 0.23 & --- & 0.11 & 0.11 & 68.7 & --- & 40.0 & 39.9 \\
                \hline
                5 & 89 & 0.23 & --- & 0.11 & 0.11 & 68.5 & --- & 40.0 & 39.9 \\
                \hline
                6 & 415 & 0.23 & --- & 0.14 & 0.11 & 68.4 & --- & 39.6 & 39.9 \\
                \hline
                7 & 2'372 & 0.25 & --- & 1.54 & 0.13 & 68.6 & --- & 40.1 & 40.2 \\
                \hline
                8 & 16'072 & 0.35 & --- & $>$ 180 & 0.19 & 70.1 & --- & $>$ 42.6 & 41.9 \\
                \hline
                9 & 125'673 & 1.25 & --- &  & 0.77 & 85.8 & --- &  & 59.8 \\
                \hline
                10 & 1'112'083 & 10.02 & --- &  & 6.56 & 228.1 & --- &  & 239.6 \\
                \hline
                11 & 10'976'184 & 104.52 & --- &  & 69.04 & 1'741.6 & --- &  & 2'158.7 \\
                \hline
            \end{tabular}
            \caption{Spotřebovaný čas a paměť při prohledávání úplných grafů s rostoucím počtem vrcholů. Výpočty probíhající více než 180 sekund byly ukončeny.}
        \end{table}

    \section{Multi-cyklické grafy}
        Pro testování algoritmů vyhledávání všech cyklů v řidkých orientovaných grafech byly vygenerované multi-cyklické grafy s o 200 vrcholech a 200 až 250 hranách (simulace rostoucí hustoty grafu). Tyto grafy jsou k dispozici ve složce \texttt{/graphs/multicycle}.

        \begin{table}[!h]
            \centering
            \begin{tabular}{|| c | r || r | r | r | r || r | r | r | r ||}
                \hline
                \multicolumn{2}{|| c ||}{} & \multicolumn{4}{c ||}{Čas [s]} & \multicolumn{4}{c ||}{Paměť [MiB]}\\
                \hhline{==========}
                \multicolumn{1}{|| c}{$|E|$} & \multicolumn{1}{| c ||}{\# cyklů} & \multicolumn{1}{c |}{NX} & \multicolumn{1}{c |}{BF} & \multicolumn{1}{c |}{WEIN} & \multicolumn{1}{c ||}{HJ} & \multicolumn{1}{c |}{NX} & \multicolumn{1}{c |}{BF} & \multicolumn{1}{c |}{WEIN} & \multicolumn{1}{c ||}{HJ} \\
                \hhline{==========}
                200 & 1 & 0.24 & --- & 0.12 & 0.17 & 69.2 & --- & 40.6 & 40.8 \\
                \hline
                205 & 7 & 0.26 & --- & 0.12 & 0.16 & 68.8 & --- & 41.0 & 40.8 \\
                \hline
                210 & 30 & 0.24 & --- & 0.12 & 0.24 & 69.1 & --- & 40.7 & 41.0 \\
                \hline
                215 & 54 & 0.25 & --- & 0.12 & 0.26 & 69.0 & --- &  40.9 & 41.2 \\
                \hline
                220 & 143 & 0.28 & --- & 0.14 & 0.56 & 69.2 & --- & 40.8 & 42.6 \\
                \hline
                225 & 350 & 0.37 & --- & 0.27 & 1.03 & 69.2 & --- & 41.1 & 45.6 \\
                \hline
                230 & 2'494 & 0.69 & --- & 9.88 & 2.78 & 71.1 & --- & 45.4 & 55.9 \\
                \hline
                235 & 6'027 & 0.95 & --- & 46.23 & 3.73 & 75.0 & --- & 52.7 & 61.6 \\
                \hline
                240 & 7'339 & 1.98 & --- & 137.43 & 8.91 &  76.1 & --- & 55.6 & 88.4 \\
                \hline
                245 & 17'809 & 5.74 & --- & $>$ 180 & 24.12 & 91.3 & --- & $>$ 64.0 & 181.8 \\
                \hline
                250 & 119'589 & 23.59 & --- &  & $>$ 180 &  177.6 & --- &  &  $>$ 1'441.5 \\
                \hline
            \end{tabular}
            \caption{Spotřebovaný čas a paměť při prohledávání multi-cyklických grafů pro $|V|~=~200$ s rostoucím počet hran. Výpočty probíhající déle než 180 sekund byly ukončeny.}
        \end{table}

        Znovu bylo potvrzeno, že časová složitost algoritmu WEIN roste rychleji než u ostatních algoritmů. Pro multi-cyklický graf s 200 vrcholy, 225 hranami a 350 cykly byl čas výpočtu algoritmu WEIN 0.27 sekund a algoritmu NX 0.37 sekund, ale pro graf s 200 vrcholy, 240 hranami a 7'339 cykly byl již čas výpočtu algoritmu WEIN 137.43 sekund a algoritmu NX pouhých 1.98 sekund.

        Pro úplné grafy, sice časová složitost algoritmu HJ rostla rychleji než NX, ale pro grafy do 11-ti vrcholů byl algoritmus HJ rychlejší. Toto tvrzení pro multi-cyklické grafy, které simulují řidké grafy, neplatí. Zde rostou časové nároky algoritmu HJ velice rychle. Pro porovnání: algoritmus NX nalezne všechny cykly v multi-cyklickém grafu o 200 vrcholech, 235 hranách a 6'027 cyklech za 0.95 sekund a algoritmus HJ za 3.73 sekund, ale pro 200 vrcholů, 250 hran a 119'589 cyklů, které algoritmus NX nalezne za 23.59 sekund, již algoritmus HJ nestihne doběhnout v časovém limitu tři minut. Tento problém algoritmu HJ pramení z využívání fronty, ve které jsou uloženy všechny rozpracované cesty, což vede na opakované prohledávání jednotlivých vrcholů. Další nevýhodou fronty je její vysoká (zbytečná) paměťová náročnost v případě nízkéno počtu cyklů v poměru k počtu vrcholů. Problém vysokých paměťových nároků lze vidět v případě multi-cyklického grafu s 200 vrcholy, 250 hranami a 119'589 cykly. V tomto případě algoritmus NX využil při hledání cyklů maximálně 177.6 MiB paměti, ale algoritmus HJ, který ani nestačil doběhnout, již spotřeboval 1'441.5 MiB paměti.

\chapter{Závěr}
    \label{chapter:Conclusion}
    \lipsum[2]
